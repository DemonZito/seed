/*
	Seed is an eco-friendly Go library for creating cross-platform applications that work on the Desktop, Mobile and Web.
	
	Example:
		
		package main

		import "github.com/qlova/seed"

		func main() {
			var App = seed.New()
			App.SetName("Hello World")
			App.SetText("Hello World")
			App.Launch()
		}

*/

package seed

import "github.com/qlova/seed/worker"
import "github.com/qlova/seed/style"
import "github.com/qlova/seed/interfaces"

import (
	"net/http"
	"fmt"
	"path"
	"path/filepath"
	"bytes"
	"os"
	"log"
	"html"
	"strings"
)

import "github.com/NYTimes/gziphandler"

//TODO cleanup
var ServiceWorker worker.Service

//TODO cleanup
func RegisterAsset(path string) {
	ServiceWorker.Assets = append(ServiceWorker.Assets, path)
}

//DEPRECIATED
func (seed Seed) ID() string {
	return seed.id
}

/*Set the name of the application generated by this seed.

	**Desktop** 
	this will be shown on the titlebar.
	
	**Mobile**
	This will become the name of the app.
	
	**Web**
	This will become the name of the tab.
*/
func (seed Seed) SetName(name string) {
	seed.manifest.Name = name
}

/*Set the description of the application generated by this seed.

	**Desktop** 
	N/A
	
	**Mobile**
	This will become the description of the app.
	
	**Web**
	N/A
*/
func (seed Seed) SetDescription(description string) {
	seed.manifest.Description = description
}

/*Set the icon for the application generated by this seed.

	**Desktop** 
	This will be the icon shown on the titlebar and in the taskbar.
	
	**Mobile**
	This will become the icon for the app.
	
	**Web**
	This will become the icon for the tab.
*/
func (seed Seed) SetIcon(path string) {
	//TODO
}

//TODO Should be Internal.
func (seed Seed) SetTag(tag string) {
	seed.tag = tag
}
//TODO Should be Internal.
func (seed Seed) SetAttributes(attr string) {
	seed.attr = attr
}
//TODO Should be Internal.
func (seed Seed) Attributes() string {
	return seed.attr
}

//Add a font to the seed.
//TODO merge with style?
/*func (seed Seed) AddFont(name, file, weight string) {
	
	switch weight {
		case "black":
			weight = "900"
		case "semi-bold":
			weight = "600"
		case "regular":
			weight = "400"
		case "light":
			weight = "300"
		case "extra-light":
			weight = "200"
	}
	
	RegisterAsset(file)
	
	seed.fonts.Write([]byte(`@font-face {
	font-family: '`+name+`';
	src: url('`+file+`');
	font-weight: `+weight+`;
}
`))
}*/

//Does this need to be here?
func (seed Seed) GetStyle() *style.Style {
	return &seed.Style
}

func (seed Seed) Page() bool {
	return seed.page
}

func (seed Seed) Require(script string) {
	seed.scripts = append(seed.scripts, script)
}

//Add a child seed to this seed.
func (seed Seed) Add(child interfaces.App) {
	seed.children = append(seed.children, child)
	child.SetParent(seed)
}

//Add a handler to the seed, when this seed is launched as root, the handlers will be executed for each incomming request.
func (seed Seed) AddHandler(handler func(w http.ResponseWriter, r *http.Request)) {
	seed.handlers = append(seed.handlers, handler)
}


func (seed Seed) GetParent() interfaces.App {
	return seed.parent
}


func (seed Seed) SetParent(parent interfaces.App) {
	seed.parent = parent
}

func (seed Seed) GetChildren() []interfaces.App {
	return seed.children
}

//Add text, html or whatever!
func (seed Seed) SetContent(data string) {
	seed.content = []byte(data)
}

//Set the text content of the seed.
func (seed Seed) SetText(data string) {
	data = html.EscapeString(data)
	data = strings.Replace(data, "\n", "<br>", -1)
	data = strings.Replace(data, "  ", "&nbsp;", -1)
	data = strings.Replace(data, "\t", "&emsp;", -1)
	seed.content = []byte(data)
}

type Client struct {
	client
}

func (client Client) WriteString(s string) {
	client.client.ResponseWriter.Write([]byte(s))
}

type client struct {
	http.ResponseWriter
	*http.Request
}

//Set the text content of the seed which will be dynamic at runtime.
func (seed Seed) SetDynamicText(f func(Client)) {
	seed.dynamicText = f
}


func (seed Seed) OnClick(f func(Script)) {
	if seed.onclick == nil {
		seed.onclick = f
	} else {
		var old = seed.onclick
		seed.onclick = func(q Script) {
			old(q)
			f(q)
		}
	}
}

func (seed Seed) OnReady(f func(Script)) {
	if seed.onready == nil {
		seed.onready = f
	} else {
		var old = seed.onready
		seed.onready = func(q Script) {
			old(q)
			f(q)
		}
	}
}


func (seed Seed) OnChange(f func(Script)) {
	if seed.onchange == nil {
		seed.onchange = f
	} else {
		var old = seed.onchange
		seed.onchange = func(q Script) {
			old(q)
			f(q)
		}
	}
}

func (seed Seed) buildStyleSheet(sheet *style.Sheet) {
	if data := seed.Style.Bytes(); data != nil {
		seed.styled = true
		sheet.Add("#"+seed.id, seed.Style)
	}
	for _, child := range seed.children {
		child.(Seed).buildStyleSheet(sheet)
	}
}

func (seed Seed) BuildStyleSheet() style.Sheet {
	var stylesheet = make(style.Sheet)
	seed.buildStyleSheet(&stylesheet)
	return stylesheet
}

func (seed Seed) buildFonts() map[style.Font]struct{} {
	
	var fonts = make(map[style.Font]struct{})
	if seed.font.FontFace.FontFamily != "" {
		fonts[seed.font] = struct{}{}
	}

	for _, child := range seed.children {
		for font := range child.(Seed).buildFonts() {
			fonts[font] = struct{}{}
		}
	}
	
	return fonts
}

func (seed Seed) BuildFonts() []byte {
	var buffer bytes.Buffer
	
	var fonts = seed.buildFonts()

	for font := range fonts {
		buffer.WriteString("@font-face {")
		buffer.Write(font.Bytes())
		buffer.WriteByte('}')
	}

	return buffer.Bytes()
}

type dynamicHandler struct {
	id string
	handler func(Client)
}

func (seed Seed) buildDynamicHandler(handler *[]dynamicHandler) {
	
	if seed.dynamicText != nil {
		(*handler) = append((*handler), dynamicHandler{
			id: seed.id,
			handler: seed.dynamicText,
		})
	}
	
	for _, child := range seed.children {
		child.(Seed).buildDynamicHandler(handler)
	}
}


func (seed Seed) BuildDynamicHandler() (func(w http.ResponseWriter, r *http.Request)) {
	var handlers = make([]dynamicHandler, 0)
	seed.buildDynamicHandler(&handlers)
	
	if len(handlers) == 0 {
		return nil
	}

	return func(w http.ResponseWriter, r *http.Request) {
		for _, handler := range handlers {
			w.Write([]byte(`"`))
			w.Write([]byte(handler.id))
			w.Write([]byte(`":"`))
			handler.handler(Client{client{
				Request: r,
				ResponseWriter: w, 
			}})
			w.Write([]byte(`"`))
		}
	}
}

func (seed Seed) Render() ([]byte) {
	var html bytes.Buffer
	
	html.WriteByte('<')
	html.WriteString(seed.tag)
	html.WriteByte(' ')
	if seed.attr != "" {
		html.WriteString(seed.attr)
		html.WriteByte(' ')
	}
	html.WriteString("id='")
	html.WriteString(fmt.Sprint(seed.id))
	html.WriteByte('\'')
	
	if seed.attr != "" {
		html.WriteString("class='")
		html.WriteString(seed.class)
		html.WriteByte('\'')
	}
	
	if data := seed.Style.Bytes(); !seed.styled && data != nil {
		html.WriteString(" style='")
		html.Write(data)
		html.WriteByte('\'')
	}
	
	if seed.onclick != nil {
		html.WriteString(" onclick='")
		html.Write(toJavascript(seed.onclick))
		html.WriteByte('\'')
	}
	
	if seed.onchange != nil {
		html.WriteString(" onchange='")
		html.Write(toJavascript(seed.onchange))
		html.WriteByte('\'')
	}
	
	html.WriteByte('>')
	
	if seed.content != nil {
		html.Write(seed.content)
	}
	
	for _, child := range seed.children {
		html.Write(child.Render())
	}
	
	html.WriteString("</")
	html.WriteString(seed.tag)
	html.WriteByte('>')
	
	return html.Bytes()
}

//TODO random port, can be set with enviromental variables.
func (seed Seed) Launch() error {
	return seed.Host(":1234")
}

//TODO Depreciate
func (seed Seed) Host(hostport string) error {
	
	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
    if err != nil {
            log.Fatal(err)
    }
    
	var style = seed.BuildStyleSheet().Bytes()
	
	var html = seed.Render()
	var fonts = seed.BuildFonts()
	var worker = ServiceWorker.Render()
	var manifest = seed.manifest.Render()
	
	var dynamic = seed.BuildDynamicHandler()
	
	var scripts = seed.Scripts()
	var onready = seed.BuildOnReady()
	
	var buffer bytes.Buffer
	buffer.Write([]byte(`<html><head>
		<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, target-densitydpi=device-dpi">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="theme-color" content="#ffffff00">
		
		<title>`+seed.manifest.Name+`</title>
		
		

		<link rel="manifest" href="/app.webmanifest">`))
	
	for script := range scripts {
		if path.Ext(script) == ".js" { 
			buffer.Write([]byte(`<script src="`+script+`"></script>`))
		} else if path.Ext(script) == ".css" {
			buffer.Write([]byte(`<link rel="stylesheet" href="`+script+`" />`))
		}
	}
		
	buffer.Write([]byte(`<script>
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', function() {
					navigator.serviceWorker.register('/index.js').then(function(registration) {
						console.log('ServiceWorker registration successful with scope: ', registration.scope);
					}, function(err) {
						console.log('ServiceWorker registration failed: ', err);
					});
				});
			}
		</script>
		
		
		<style>
	`))
	
	buffer.Write(fonts)
	buffer.Write(style)
	
	
	var gotoBody string
	for _, page := range pages {
		gotoBody += "document.getElementById('"+page.ID()+"').style.display = 'none';"
	}
	gotoBody += "document.getElementById(page).style.display = 'inline-flex';"
	
	buffer.Write([]byte(`
		</style>
			
		<style>
			
			::-webkit-scrollbar { 
				display: none; 
			}
			
			 html, body {
				overscroll-behavior: none; 
				cursor: pointer; 
				margin: 0; 
				height: 100vh;
				width: 100vw;
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				-webkit-tap-highlight-color: transparent;
				
				/* Some nice defaults for centering content. */
				display: inline-flex;
				align-items: center;
				justify-content: center;
				flex-direction: row;
			}
		</style>
		
		<script>
			var get = function(id) {
				return document.getElementById(id)
			}
			var goto = function(page) {
				` + gotoBody + `
			}
			
			if (window.location.hostname.includes("localhost")) {
				let url = new URL('/socket', window.location.href);
				url.protocol = url.protocol.replace('http', 'ws');
				let Socket = new WebSocket(url.href);
				Socket.onclose = function() {
					close();
				}
				Socket.onerror = function() {
					close();
				}
				//Disable refresh on chrome because otherwise the app will close.
				document.onkeydown = function() {    
					switch (event.keyCode) { 
						case 116 : //F5 button
							event.returnValue = false;
							event.keyCode = 0;
							return false; 
						case 82 : //R button
							if (event.ctrlKey) { 
								event.returnValue = false; 
								event.keyCode = 0;  
								return false; 
							} 
					}
				}
			}
			
		`))
	
	buffer.Write(onready)
	
	if dynamic != nil {
		buffer.WriteString(`
			var dynamic = new XMLHttpRequest();

			dynamic.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var updates = JSON.parse(this.responseText);
					for (let id in updates) {
						document.getElementById(id).textContent = updates[id];
					}
				}
			};

			dynamic.open("GET", "/dynamic", true);
			dynamic.send();`)
	}

	buffer.Write([]byte(`
		</script>
		
		</head><body>
	`))
	buffer.Write(html)
	buffer.Write([]byte(`</body></html>`))
	
	minified, err := mini(buffer.Bytes())
	if err != nil {
		return err
	}

	var LocalClients = 0
	
	withoutGz := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request)  {
		
		if r.URL.Path == "/socket" && strings.Contains(r.RemoteAddr, "[::1]") {
			LocalClients++
			SingleLocalConnection = LocalClients == 1
			socket(w, r)
			return
		}
		
		if r.URL.Path == "/dynamic" && dynamic != nil {
			w.Write([]byte("{"))
			dynamic(w, r)
			w.Write([]byte("}"))
			return
		}

		if embedded(w, r) {
			return
		}
		
		if len(r.URL.Path) > 5 && r.URL.Path[:6] == "/call/" {
			callHandler(w, r, r.URL.Path[6:] )
			return
		}
		
		fmt.Println(r.URL.Path)
		
		if r.URL.Path != "/" {
			for _, handler := range seed.handlers {
				handler(w, r)
			}
			
			if path.Ext(r.URL.Path) == "" {
				return
			}
		}
		
		if r.URL.Path == "/index.js" {
			if strings.Contains(r.RemoteAddr, "[::1]") {
				//Don't use a web worker if we are running locally.
				w.Header().Set("content-type", "text/javascript")
				w.Write([]byte(`self.addEventListener('install', () => {self.skipWaiting();});`))
				
			} else {
				w.Header().Set("content-type", "text/javascript")
				w.Write(worker)
			}
			return
		}
		
		if r.URL.Path == "/app.webmanifest" {
			w.Header().Set("content-type", "application/json")
			w.Write(manifest)
			return
		}
		
		
		if path.Ext(r.URL.Path) != "" {
			http.ServeFile(w, r, dir+"/assets"+r.URL.Path)
			return
		}

		w.Write(minified)
	})
	
	withGz := gziphandler.GzipHandler(withoutGz)
	
	http.Handle("/", withGz)
	
	//Launch the app if possible.
	go launch(hostport)
	
	return http.ListenAndServe(hostport, nil)
}
