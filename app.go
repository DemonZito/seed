/*
	Seed is an eco-friendly Go library for creating cross-platform applications that work on the Desktop, Mobile and Web.
	
	Example:
		
		package main

		import "github.com/qlova/seed"

		func main() {
			var App = seed.New()
			App.SetName("Hello World")
			App.SetText("Hello World")
			App.Launch()
		}

*/

package seed

//Internal packages.
import "github.com/qlova/script"
import "github.com/qlova/script/language/javascript"

import "github.com/qlova/seed/worker"
import "github.com/qlova/seed/manifest"
import "github.com/qlova/seed/style"
import "github.com/qlova/seed/interfaces"

import (
	"net/http"
	"fmt"
	"path"
	"path/filepath"
	"bytes"
	"os"
	"log"
	"html"
	"strings"
	
	"math/big"
	"encoding/base64"
)

import "github.com/NYTimes/gziphandler"

//TODO cleanup
var ServiceWorker worker.Service

//TODO cleanup
func RegisterAsset(path string) {
	ServiceWorker.Assets = append(ServiceWorker.Assets, path)
}

//All seeds have a unique id.
var id int64 = 1;

//#seedsafe
type Slice []*seed
type Seed struct {
	*seed
}

type seed struct {
	style.Style
	
	id string
	tag, attr, class string
	children []interfaces.App
	
	styled bool
	
	fonts bytes.Buffer
	
	content []byte
	page bool
	
	onclick func(Script)
	
	parent interfaces.App
	
	manifest manifest.Manifest
	handlers []func(w http.ResponseWriter, r *http.Request)
	
	dynamicText func(Client)
}

//Create and return a new seed.
func New() Seed {
	seed := new(seed)
	
	//Seed identification is compressed to base64.
	seed.id = base64.RawURLEncoding.EncodeToString(big.NewInt(id).Bytes())
	id++

	seed.Style = style.New()	
	seed.tag = "div"
	
	//All seeds have the potential to be the root seed, so they all need a minimal viable manifest.
	seed.manifest = manifest.New()

	return Seed{seed:seed}
}

//DEPRECIATED
func (seed Seed) ID() string {
	return seed.id
}

/*Set the name of the application generated by this seed.

	**Desktop** 
	this will be shown on the titlebar.
	
	**Mobile**
	This will become the name of the app.
	
	**Web**
	This will become the name of the tab.
*/
func (seed Seed) SetName(name string) {
	seed.manifest.Name = name
}

/*Set the description of the application generated by this seed.

	**Desktop** 
	N/A
	
	**Mobile**
	This will become the description of the app.
	
	**Web**
	N/A
*/
func (seed Seed) SetDescription(description string) {
	seed.manifest.Description = description
}

/*Set the icon for the application generated by this seed.

	**Desktop** 
	This will be the icon shown on the titlebar and in the taskbar.
	
	**Mobile**
	This will become the icon for the app.
	
	**Web**
	This will become the icon for the tab.
*/
func (seed Seed) SetIcon(path string) {
	//TODO
}

//TODO Should be Internal.
func (seed Seed) SetTag(tag string) {
	seed.tag = tag
}
//TODO Should be Internal.
func (seed Seed) SetAttributes(attr string) {
	seed.attr = attr
}
//TODO Should be Internal.
func (seed Seed) Attributes() string {
	return seed.attr
}

//Add a font to the seed.
//TODO merge with style?
func (seed Seed) AddFont(name, file, weight string) {
	
	switch weight {
		case "black":
			weight = "900"
		case "semi-bold":
			weight = "600"
		case "regular":
			weight = "400"
		case "light":
			weight = "300"
		case "extra-light":
			weight = "200"
	}
	
	RegisterAsset(file)
	
	seed.fonts.Write([]byte(`@font-face {
	font-family: '`+name+`';
	src: url('`+file+`');
	font-weight: `+weight+`;
}
`))
}

//Does this need to be here?
func (seed Seed) GetStyle() *style.Style {
	return &seed.Style
}

func (seed Seed) Page() bool {
	return seed.page
}

//Add a child seed to this seed.
func (seed Seed) Add(child interfaces.App) {
	seed.children = append(seed.children, child)
	child.SetParent(seed)
}

//Add a handler to the seed, when this seed is launched as root, the handlers will be executed for each incomming request.
func (seed Seed) AddHandler(handler func(w http.ResponseWriter, r *http.Request)) {
	seed.handlers = append(seed.handlers, handler)
}


func (seed Seed) GetParent() interfaces.App {
	return seed.parent
}


func (seed Seed) SetParent(parent interfaces.App) {
	seed.parent = parent
}

func (seed Seed) GetChildren() []interfaces.App {
	return seed.children
}

//Add text, html or whatever!
func (seed Seed) SetContent(data string) {
	seed.content = []byte(data)
}

//Set the text content of the seed.
func (seed Seed) SetText(data string) {
	data = html.EscapeString(data)
	data = strings.Replace(data, "\n", "<br>", -1)
	seed.content = []byte(data)
}

type Client struct {
	client
}

func (client Client) WriteString(s string) {
	client.client.ResponseWriter.Write([]byte(s))
}

type client struct {
	http.ResponseWriter
	*http.Request
}

//Set the text content of the seed which will be dynamic at runtime.
func (seed Seed) SetDynamicText(f func(Client)) {
	seed.dynamicText = f
}


func (seed Seed) OnClick(f func(Script)) {
	seed.onclick = f
}

func SetPage(page interfaces.App) {
	for _, child := range page.GetParent().GetChildren() {
		if child.Page() {
			if child.ID() == page.ID() {
				child.GetStyle().SetVisible()
			} else {
				child.GetStyle().SetHidden()
			}
		}
	}
}

func (seed Seed) buildStyleSheet(sheet *style.Sheet) {
	if data := seed.Style.Render(); data != nil {
		seed.styled = true
		seed.class = sheet.CreateAndReturnClassesFor(seed.id, string(data))
	}
	for _, child := range seed.children {
		child.(Seed).buildStyleSheet(sheet)
	}
}

func (seed Seed) BuildStyleSheet() *style.Sheet {
	var stylesheet style.Sheet
	seed.buildStyleSheet(&stylesheet)
	return &stylesheet
}

type dynamicHandler struct {
	id string
	handler func(Client)
}

func (seed Seed) buildDynamicHandler(handler *[]dynamicHandler) {
	
	if seed.dynamicText != nil {
		(*handler) = append((*handler), dynamicHandler{
			id: seed.id,
			handler: seed.dynamicText,
		})
	}
	
	for _, child := range seed.children {
		child.(Seed).buildDynamicHandler(handler)
	}
}


func (seed Seed) BuildDynamicHandler() (func(w http.ResponseWriter, r *http.Request)) {
	var handlers = make([]dynamicHandler, 0)
	seed.buildDynamicHandler(&handlers)
	
	if len(handlers) == 0 {
		return nil
	}

	return func(w http.ResponseWriter, r *http.Request) {
		for _, handler := range handlers {
			w.Write([]byte(`"`))
			w.Write([]byte(handler.id))
			w.Write([]byte(`":"`))
			handler.handler(Client{client{
				Request: r,
				ResponseWriter: w, 
			}})
			w.Write([]byte(`"`))
		}
	}
}

func (seed Seed) Render() ([]byte) {
	var html bytes.Buffer
	
	html.WriteByte('<')
	html.WriteString(seed.tag)
	html.WriteByte(' ')
	if seed.attr != "" {
		html.WriteString(seed.attr)
		html.WriteByte(' ')
	}
	html.WriteString("id='")
	html.WriteString(fmt.Sprint(seed.id))
	html.WriteByte('\'')
	
	if seed.attr != "" {
		html.WriteString("class='")
		html.WriteString(seed.class)
		html.WriteByte('\'')
	}
	
	if data := seed.Style.Render(); !seed.styled && data != nil {
		html.WriteString(" style='")
		html.Write(data)
		html.WriteByte('\'')
	}
	
	if seed.onclick != nil {
		html.WriteString(" onclick='")
		
		var program = script.NewProgram(func(q script.Script) {
			var s = Script{seedScript: &seedScript{ Script:q }}
			seed.onclick(s)
			for i := 0; i < s.promises; i++ {
				q.Raw("Javascript", "}; request.send();")
			}
			s.promises = 0
		})
		source, err := program.Source(Javascript.Language())
		if err != nil {
			panic(err)
		}
		
		html.Write([]byte(source))
		html.WriteByte('\'')
	}
	html.WriteByte('>')
	
	if seed.content != nil {
		html.Write(seed.content)
	}
	
	for _, child := range seed.children {
		html.Write(child.Render())
	}
	
	html.WriteString("</")
	html.WriteString(seed.tag)
	html.WriteByte('>')
	
	return html.Bytes()
}

//TODO random port, can be set with enviromental variables.
func (seed Seed) Launch() error {
	return seed.Host(":1234")
}

//TODO Depreciate
func (seed Seed) Host(hostport string) error {
	
	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
    if err != nil {
            log.Fatal(err)
    }
    
	var style = seed.BuildStyleSheet().Render()
	
	var html = seed.Render()
	var worker = ServiceWorker.Render()
	var manifest = seed.manifest.Render()
	
	var dynamic = seed.BuildDynamicHandler()
	
	var buffer bytes.Buffer
	buffer.Write([]byte(`<html><head>
		<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, target-densitydpi=device-dpi">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="theme-color" content="#ffffff00">
		
		<title>`+seed.manifest.Name+`</title>

		<link rel="manifest" href="/app.webmanifest">`))
		
	if UsingMap {
		buffer.Write([]byte(`	<link rel="stylesheet" href="leaflet.css" />
								<script src="leaflet.js"></script>
		`))
	}
		
	buffer.Write([]byte(`<script>
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', function() {
					navigator.serviceWorker.register('/index.js').then(function(registration) {
						console.log('ServiceWorker registration successful with scope: ', registration.scope);
					}, function(err) {
						console.log('ServiceWorker registration failed: ', err);
					});
				});
			}
		</script>
		
		
		<style>
	`))
	
	buffer.Write(seed.fonts.Bytes())
	buffer.Write(style.Bytes())
	
	
	var gotoBody string
	for _, page := range pages {
		gotoBody += "document.getElementById('"+page.ID()+"').style.display = 'none';"
	}
	gotoBody += "document.getElementById(page).style.display = 'block';"
	
	buffer.Write([]byte(`
		</style>
			
		<style>
			
			::-webkit-scrollbar { 
				display: none; 
			}
			
			 html, body {
				overscroll-behavior: none; 
				cursor: pointer; 
				margin: 0; 
				height: 100%;
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				-webkit-tap-highlight-color: transparent;
				
				/* Some nice defaults for centering content. */
				display: inline-flex;
				align-items: center;
				justify-content: center;
				flex-direction: row;
			}
		</style>
		
		<script>
			var get = function(id) {
				return document.getElementById(id)
			}
			var goto = function(page) {
				` + gotoBody + `
			}
		`))
	
	if dynamic != nil {
		buffer.WriteString(`
			var dynamic = new XMLHttpRequest();

			dynamic.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var updates = JSON.parse(this.responseText);
					for (let id in updates) {
						document.getElementById(id).textContent = updates[id];
					}
				}
			};

			dynamic.open("GET", "/dynamic", true);
			dynamic.send();`)
	}

	buffer.Write([]byte(`
		</script>
		
		</head><body>
	`))
	buffer.Write(html)
	buffer.Write([]byte(`</body></html>`))
	
	minified, err := mini(buffer.Bytes())
	if err != nil {
		return err
	}
	
	withoutGz := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request)  {
		
		fmt.Println(r.URL.Path)
		
		if r.URL.Path == "/dynamic" && dynamic != nil {
			w.Write([]byte("{"))
			dynamic(w, r)
			w.Write([]byte("}"))
			return
		}
		
		if len(r.URL.Path) > 5 && r.URL.Path[:6] == "/call/" {
			callHandler(w, r, r.URL.Path[6:] )
			return
		}
		
		if r.URL.Path != "/" {
			for _, handler := range seed.handlers {
				handler(w, r)
			}
			
			if path.Ext(r.URL.Path) == "" {
				return
			}
		}
		
		if r.URL.Path == "/index.js" {
			w.Header().Set("content-type", "text/javascript")
			w.Write(worker)
			return
		}
		
		if r.URL.Path == "/app.webmanifest" {
			w.Header().Set("content-type", "application/json")
			w.Write(manifest)
			return
		}
		
		
		if path.Ext(r.URL.Path) != "" {
			http.ServeFile(w, r, dir+"/assets"+r.URL.Path)
			return
		}

		w.Write(minified)
	})
	
	withGz := gziphandler.GzipHandler(withoutGz)
	
	http.Handle("/", withGz)
	
	//Launch the app if possible.
	go launch(hostport)
	
	return http.ListenAndServe(hostport, nil)
}
